// Code generated by protoc-gen-zig
///! package pdpb
const std = @import("std");

const pb = @import("protobuf");
const fd = pb.fd;
/// import package replication_modepb
const replication_modepb = @import("replication_modepb.pb.zig");
/// import package metapb
const metapb = @import("metapb.pb.zig");
/// import package raft_serverpb
const raft_serverpb = @import("raft_serverpb.pb.zig");
/// import package eraftpb
const eraftpb = @import("eraftpb.pb.zig");
/// import package rustproto
const rustproto = @import("rustproto.pb.zig");
/// import package gogoproto
const gogoproto = @import("gogoproto.pb.zig");

pub const EventType = enum(i32) {
    PUT = 0,
    DELETE = 1,
    _,
};

pub const ErrorType = enum(i32) {
    OK = 0,
    UNKNOWN = 1,
    NOT_BOOTSTRAPPED = 2,
    STORE_TOMBSTONE = 3,
    ALREADY_BOOTSTRAPPED = 4,
    INCOMPATIBLE_VERSION = 5,
    REGION_NOT_FOUND = 6,
    GLOBAL_CONFIG_NOT_FOUND = 7,
    DUPLICATED_ENTRY = 8,
    ENTRY_NOT_FOUND = 9,
    INVALID_VALUE = 10,
    DATA_COMPACTED = 11,
    _,
};

pub const ServiceMode = enum(i32) {
    UNKNOWN_SVC_MODE = 0,
    PD_SVC_MODE = 1,
    API_SVC_MODE = 2,
    _,
};

pub const CheckPolicy = enum(i32) {
    SCAN = 0,
    APPROXIMATE = 1,
    USEKEY = 2,
    _,
};

pub const OperatorStatus = enum(i32) {
    SUCCESS = 0,
    TIMEOUT = 1,
    CANCEL = 2,
    REPLACE = 3,
    RUNNING = 4,
    _,
};

pub const QueryKind = enum(i32) {
    Others = 0,
    GC = 1,
    Get = 2,
    Scan = 3,
    Coprocessor = 4,
    Delete = 5,
    DeleteRange = 6,
    Put = 7,
    Prewrite = 8,
    AcquirePessimisticLock = 9,
    Commit = 10,
    Rollback = 11,
    _,
};

pub const WatchGlobalConfigRequest = struct {
    config_path: []const u8 = &.{},
    revision: i64 = 0,

    pub const _desc_table = .{
        .config_path = fd(1, .{ .scalar = .string }),
        .revision = fd(2, .{ .scalar = .int64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const WatchGlobalConfigResponse = struct {
    changes: std.ArrayListUnmanaged(GlobalConfigItem) = .empty,
    revision: i64 = 0,
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .changes = fd(1, .{ .repeated = .submessage }),
        .revision = fd(2, .{ .scalar = .int64 }),
        .header = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const StoreGlobalConfigRequest = struct {
    changes: std.ArrayListUnmanaged(GlobalConfigItem) = .empty,
    config_path: []const u8 = &.{},

    pub const _desc_table = .{
        .changes = fd(1, .{ .repeated = .submessage }),
        .config_path = fd(2, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const StoreGlobalConfigResponse = struct {
    @"error": ?Error = null,

    pub const _desc_table = .{
        .@"error" = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const LoadGlobalConfigRequest = struct {
    names: std.ArrayListUnmanaged([]const u8) = .empty,
    config_path: []const u8 = &.{},

    pub const _desc_table = .{
        .names = fd(1, .{ .repeated = .{ .scalar = .string } }),
        .config_path = fd(2, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const LoadGlobalConfigResponse = struct {
    items: std.ArrayListUnmanaged(GlobalConfigItem) = .empty,
    revision: i64 = 0,

    pub const _desc_table = .{
        .items = fd(1, .{ .repeated = .submessage }),
        .revision = fd(2, .{ .scalar = .int64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GlobalConfigItem = struct {
    name: []const u8 = &.{},
    value: []const u8 = &.{},
    @"error": ?Error = null,
    kind: EventType = @enumFromInt(0),
    payload: []const u8 = &.{},

    pub const _desc_table = .{
        .name = fd(1, .{ .scalar = .string }),
        .value = fd(2, .{ .scalar = .string }),
        .@"error" = fd(3, .submessage),
        .kind = fd(4, .@"enum"),
        .payload = fd(5, .{ .scalar = .bytes }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const RequestHeader = struct {
    cluster_id: u64 = 0,
    sender_id: u64 = 0,

    pub const _desc_table = .{
        .cluster_id = fd(1, .{ .scalar = .uint64 }),
        .sender_id = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ResponseHeader = struct {
    cluster_id: u64 = 0,
    @"error": ?Error = null,

    pub const _desc_table = .{
        .cluster_id = fd(1, .{ .scalar = .uint64 }),
        .@"error" = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const Error = struct {
    type: ErrorType = @enumFromInt(0),
    message: []const u8 = &.{},

    pub const _desc_table = .{
        .type = fd(1, .@"enum"),
        .message = fd(2, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const TsoRequest = struct {
    header: ?RequestHeader = null,
    count: u32 = 0,
    dc_location: []const u8 = &.{},

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .count = fd(2, .{ .scalar = .uint32 }),
        .dc_location = fd(3, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const Timestamp = struct {
    physical: i64 = 0,
    logical: i64 = 0,
    suffix_bits: u32 = 0,

    pub const _desc_table = .{
        .physical = fd(1, .{ .scalar = .int64 }),
        .logical = fd(2, .{ .scalar = .int64 }),
        .suffix_bits = fd(3, .{ .scalar = .uint32 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const TsoResponse = struct {
    header: ?ResponseHeader = null,
    count: u32 = 0,
    timestamp: ?Timestamp = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .count = fd(2, .{ .scalar = .uint32 }),
        .timestamp = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const BootstrapRequest = struct {
    header: ?RequestHeader = null,
    store: ?metapb.Store = null,
    region: ?metapb.Region = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .store = fd(2, .submessage),
        .region = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const BootstrapResponse = struct {
    header: ?ResponseHeader = null,
    replication_status: ?replication_modepb.ReplicationStatus = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .replication_status = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const IsBootstrappedRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const IsBootstrappedResponse = struct {
    header: ?ResponseHeader = null,
    bootstrapped: bool = false,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .bootstrapped = fd(2, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AllocIDRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AllocIDResponse = struct {
    header: ?ResponseHeader = null,
    id: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .id = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const IsSnapshotRecoveringRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const IsSnapshotRecoveringResponse = struct {
    header: ?ResponseHeader = null,
    marked: bool = false,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .marked = fd(2, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetStoreRequest = struct {
    header: ?RequestHeader = null,
    store_id: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .store_id = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetStoreResponse = struct {
    header: ?ResponseHeader = null,
    store: ?metapb.Store = null,
    stats: ?StoreStats = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .store = fd(2, .submessage),
        .stats = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PutStoreRequest = struct {
    header: ?RequestHeader = null,
    store: ?metapb.Store = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .store = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PutStoreResponse = struct {
    header: ?ResponseHeader = null,
    replication_status: ?replication_modepb.ReplicationStatus = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .replication_status = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetAllStoresRequest = struct {
    header: ?RequestHeader = null,
    exclude_tombstone_stores: bool = false,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .exclude_tombstone_stores = fd(2, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetAllStoresResponse = struct {
    header: ?ResponseHeader = null,
    stores: std.ArrayListUnmanaged(metapb.Store) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .stores = fd(2, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetRegionRequest = struct {
    header: ?RequestHeader = null,
    region_key: []const u8 = &.{},
    need_buckets: bool = false,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_key = fd(2, .{ .scalar = .bytes }),
        .need_buckets = fd(3, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetRegionResponse = struct {
    header: ?ResponseHeader = null,
    region: ?metapb.Region = null,
    leader: ?metapb.Peer = null,
    down_peers: std.ArrayListUnmanaged(PeerStats) = .empty,
    pending_peers: std.ArrayListUnmanaged(metapb.Peer) = .empty,
    buckets: ?metapb.Buckets = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region = fd(2, .submessage),
        .leader = fd(3, .submessage),
        .down_peers = fd(5, .{ .repeated = .submessage }),
        .pending_peers = fd(6, .{ .repeated = .submessage }),
        .buckets = fd(7, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetRegionByIDRequest = struct {
    header: ?RequestHeader = null,
    region_id: u64 = 0,
    need_buckets: bool = false,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_id = fd(2, .{ .scalar = .uint64 }),
        .need_buckets = fd(3, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ScanRegionsRequest = struct {
    header: ?RequestHeader = null,
    start_key: []const u8 = &.{},
    limit: i32 = 0,
    end_key: []const u8 = &.{},

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .start_key = fd(2, .{ .scalar = .bytes }),
        .limit = fd(3, .{ .scalar = .int32 }),
        .end_key = fd(4, .{ .scalar = .bytes }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const Region = struct {
    region: ?*metapb.Region = null,
    leader: ?metapb.Peer = null,
    down_peers: std.ArrayListUnmanaged(PeerStats) = .empty,
    pending_peers: std.ArrayListUnmanaged(metapb.Peer) = .empty,

    pub const _desc_table = .{
        .region = fd(1, .submessage),
        .leader = fd(2, .submessage),
        .down_peers = fd(3, .{ .repeated = .submessage }),
        .pending_peers = fd(4, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ScanRegionsResponse = struct {
    header: ?ResponseHeader = null,
    region_metas: std.ArrayListUnmanaged(metapb.Region) = .empty,
    leaders: std.ArrayListUnmanaged(metapb.Peer) = .empty,
    regions: std.ArrayListUnmanaged(Region) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_metas = fd(2, .{ .repeated = .submessage }),
        .leaders = fd(3, .{ .repeated = .submessage }),
        .regions = fd(4, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetClusterConfigRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetClusterConfigResponse = struct {
    header: ?ResponseHeader = null,
    cluster: ?metapb.Cluster = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .cluster = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PutClusterConfigRequest = struct {
    header: ?RequestHeader = null,
    cluster: ?metapb.Cluster = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .cluster = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PutClusterConfigResponse = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const Member = struct {
    name: []const u8 = &.{},
    member_id: u64 = 0,
    peer_urls: std.ArrayListUnmanaged([]const u8) = .empty,
    client_urls: std.ArrayListUnmanaged([]const u8) = .empty,
    leader_priority: i32 = 0,
    deploy_path: []const u8 = &.{},
    binary_version: []const u8 = &.{},
    git_hash: []const u8 = &.{},
    dc_location: []const u8 = &.{},

    pub const _desc_table = .{
        .name = fd(1, .{ .scalar = .string }),
        .member_id = fd(2, .{ .scalar = .uint64 }),
        .peer_urls = fd(3, .{ .repeated = .{ .scalar = .string } }),
        .client_urls = fd(4, .{ .repeated = .{ .scalar = .string } }),
        .leader_priority = fd(5, .{ .scalar = .int32 }),
        .deploy_path = fd(6, .{ .scalar = .string }),
        .binary_version = fd(7, .{ .scalar = .string }),
        .git_hash = fd(8, .{ .scalar = .string }),
        .dc_location = fd(9, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetMembersRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetMembersResponse = struct {
    header: ?ResponseHeader = null,
    members: std.ArrayListUnmanaged(Member) = .empty,
    leader: ?Member = null,
    etcd_leader: ?Member = null,
    tso_allocator_leaders: std.ArrayListUnmanaged(GetMembersResponse.TsoAllocatorLeadersEntry) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .members = fd(2, .{ .repeated = .submessage }),
        .leader = fd(3, .submessage),
        .etcd_leader = fd(4, .submessage),
        .tso_allocator_leaders = fd(5, .{ .repeated = .submessage }),
    };

    pub const TsoAllocatorLeadersEntry = struct {
        key: []const u8 = &.{},
        value: ?Member = null,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .submessage),
        };

        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return pb.encode(writer, allocator, self);
        }

        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return pb.decode(@This(), reader, allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return pb.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return pb.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return pb.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return pb.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return pb.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return pb.json.stringify(@This(), self, jws);
        }
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetClusterInfoRequest = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetClusterInfoResponse = struct {
    header: ?ResponseHeader = null,
    serviceModes: std.ArrayListUnmanaged(ServiceMode) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .serviceModes = fd(2, .{ .repeated = .@"enum" }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PeerStats = struct {
    peer: ?metapb.Peer = null,
    down_seconds: u64 = 0,

    pub const _desc_table = .{
        .peer = fd(1, .submessage),
        .down_seconds = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const RegionHeartbeatRequest = struct {
    header: ?RequestHeader = null,
    region: ?metapb.Region = null,
    leader: ?metapb.Peer = null,
    down_peers: std.ArrayListUnmanaged(PeerStats) = .empty,
    pending_peers: std.ArrayListUnmanaged(metapb.Peer) = .empty,
    bytes_written: u64 = 0,
    bytes_read: u64 = 0,
    keys_written: u64 = 0,
    keys_read: u64 = 0,
    approximate_size: u64 = 0,
    interval: ?TimeInterval = null,
    approximate_keys: u64 = 0,
    term: u64 = 0,
    replication_status: ?replication_modepb.RegionReplicationStatus = null,
    query_stats: ?QueryStats = null,
    cpu_usage: u64 = 0,
    approximate_kv_size: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region = fd(2, .submessage),
        .leader = fd(3, .submessage),
        .down_peers = fd(4, .{ .repeated = .submessage }),
        .pending_peers = fd(5, .{ .repeated = .submessage }),
        .bytes_written = fd(6, .{ .scalar = .uint64 }),
        .bytes_read = fd(7, .{ .scalar = .uint64 }),
        .keys_written = fd(8, .{ .scalar = .uint64 }),
        .keys_read = fd(9, .{ .scalar = .uint64 }),
        .approximate_size = fd(10, .{ .scalar = .uint64 }),
        .interval = fd(12, .submessage),
        .approximate_keys = fd(13, .{ .scalar = .uint64 }),
        .term = fd(14, .{ .scalar = .uint64 }),
        .replication_status = fd(15, .submessage),
        .query_stats = fd(16, .submessage),
        .cpu_usage = fd(17, .{ .scalar = .uint64 }),
        .approximate_kv_size = fd(18, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ChangePeer = struct {
    peer: ?metapb.Peer = null,
    change_type: eraftpb.ConfChangeType = @enumFromInt(0),

    pub const _desc_table = .{
        .peer = fd(1, .submessage),
        .change_type = fd(2, .@"enum"),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ChangePeerV2 = struct {
    changes: std.ArrayListUnmanaged(ChangePeer) = .empty,

    pub const _desc_table = .{
        .changes = fd(1, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const TransferLeader = struct {
    peer: ?metapb.Peer = null,
    peers: std.ArrayListUnmanaged(metapb.Peer) = .empty,

    pub const _desc_table = .{
        .peer = fd(1, .submessage),
        .peers = fd(2, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const Merge = struct {
    target: ?metapb.Region = null,

    pub const _desc_table = .{
        .target = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SplitRegion = struct {
    policy: CheckPolicy = @enumFromInt(0),
    keys: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .policy = fd(1, .@"enum"),
        .keys = fd(2, .{ .repeated = .{ .scalar = .bytes } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SwitchWitness = struct {
    peer_id: u64 = 0,
    is_witness: bool = false,

    pub const _desc_table = .{
        .peer_id = fd(1, .{ .scalar = .uint64 }),
        .is_witness = fd(2, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const BatchSwitchWitness = struct {
    switch_witnesses: std.ArrayListUnmanaged(SwitchWitness) = .empty,

    pub const _desc_table = .{
        .switch_witnesses = fd(1, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const RegionHeartbeatResponse = struct {
    header: ?ResponseHeader = null,
    change_peer: ?ChangePeer = null,
    transfer_leader: ?TransferLeader = null,
    region_id: u64 = 0,
    region_epoch: ?metapb.RegionEpoch = null,
    target_peer: ?metapb.Peer = null,
    merge: ?Merge = null,
    split_region: ?SplitRegion = null,
    change_peer_v2: ?ChangePeerV2 = null,
    switch_witnesses: ?BatchSwitchWitness = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .change_peer = fd(2, .submessage),
        .transfer_leader = fd(3, .submessage),
        .region_id = fd(4, .{ .scalar = .uint64 }),
        .region_epoch = fd(5, .submessage),
        .target_peer = fd(6, .submessage),
        .merge = fd(7, .submessage),
        .split_region = fd(8, .submessage),
        .change_peer_v2 = fd(9, .submessage),
        .switch_witnesses = fd(10, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AskSplitRequest = struct {
    header: ?RequestHeader = null,
    region: ?metapb.Region = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AskSplitResponse = struct {
    header: ?ResponseHeader = null,
    new_region_id: u64 = 0,
    new_peer_ids: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .new_region_id = fd(2, .{ .scalar = .uint64 }),
        .new_peer_ids = fd(3, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportSplitRequest = struct {
    header: ?RequestHeader = null,
    left: ?metapb.Region = null,
    right: ?metapb.Region = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .left = fd(2, .submessage),
        .right = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportSplitResponse = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AskBatchSplitRequest = struct {
    header: ?RequestHeader = null,
    region: ?metapb.Region = null,
    split_count: u32 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region = fd(2, .submessage),
        .split_count = fd(3, .{ .scalar = .uint32 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SplitID = struct {
    new_region_id: u64 = 0,
    new_peer_ids: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .new_region_id = fd(1, .{ .scalar = .uint64 }),
        .new_peer_ids = fd(2, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AskBatchSplitResponse = struct {
    header: ?ResponseHeader = null,
    ids: std.ArrayListUnmanaged(SplitID) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .ids = fd(2, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportBatchSplitRequest = struct {
    header: ?RequestHeader = null,
    regions: std.ArrayListUnmanaged(metapb.Region) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .regions = fd(2, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportBatchSplitResponse = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const TimeInterval = struct {
    start_timestamp: u64 = 0,
    end_timestamp: u64 = 0,

    pub const _desc_table = .{
        .start_timestamp = fd(1, .{ .scalar = .uint64 }),
        .end_timestamp = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const RecordPair = struct {
    key: []const u8 = &.{},
    value: u64 = 0,

    pub const _desc_table = .{
        .key = fd(1, .{ .scalar = .string }),
        .value = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PeerStat = struct {
    region_id: u64 = 0,
    read_keys: u64 = 0,
    read_bytes: u64 = 0,
    query_stats: ?QueryStats = null,
    written_keys: u64 = 0,
    written_bytes: u64 = 0,

    pub const _desc_table = .{
        .region_id = fd(1, .{ .scalar = .uint64 }),
        .read_keys = fd(2, .{ .scalar = .uint64 }),
        .read_bytes = fd(3, .{ .scalar = .uint64 }),
        .query_stats = fd(4, .submessage),
        .written_keys = fd(5, .{ .scalar = .uint64 }),
        .written_bytes = fd(6, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const StoreStats = struct {
    store_id: u64 = 0,
    capacity: u64 = 0,
    available: u64 = 0,
    region_count: u32 = 0,
    sending_snap_count: u32 = 0,
    receiving_snap_count: u32 = 0,
    start_time: u32 = 0,
    applying_snap_count: u32 = 0,
    is_busy: bool = false,
    used_size: u64 = 0,
    bytes_written: u64 = 0,
    keys_written: u64 = 0,
    bytes_read: u64 = 0,
    keys_read: u64 = 0,
    interval: ?TimeInterval = null,
    cpu_usages: std.ArrayListUnmanaged(RecordPair) = .empty,
    read_io_rates: std.ArrayListUnmanaged(RecordPair) = .empty,
    write_io_rates: std.ArrayListUnmanaged(RecordPair) = .empty,
    op_latencies: std.ArrayListUnmanaged(RecordPair) = .empty,
    peer_stats: std.ArrayListUnmanaged(PeerStat) = .empty,
    query_stats: ?QueryStats = null,
    slow_score: u64 = 0,
    damaged_regions_id: std.ArrayListUnmanaged(u64) = .empty,
    is_apply_busy: bool = false,
    snapshot_stats: std.ArrayListUnmanaged(SnapshotStat) = .empty,
    slow_trend: ?SlowTrend = null,

    pub const _desc_table = .{
        .store_id = fd(1, .{ .scalar = .uint64 }),
        .capacity = fd(2, .{ .scalar = .uint64 }),
        .available = fd(3, .{ .scalar = .uint64 }),
        .region_count = fd(4, .{ .scalar = .uint32 }),
        .sending_snap_count = fd(5, .{ .scalar = .uint32 }),
        .receiving_snap_count = fd(6, .{ .scalar = .uint32 }),
        .start_time = fd(7, .{ .scalar = .uint32 }),
        .applying_snap_count = fd(8, .{ .scalar = .uint32 }),
        .is_busy = fd(9, .{ .scalar = .bool }),
        .used_size = fd(10, .{ .scalar = .uint64 }),
        .bytes_written = fd(11, .{ .scalar = .uint64 }),
        .keys_written = fd(12, .{ .scalar = .uint64 }),
        .bytes_read = fd(13, .{ .scalar = .uint64 }),
        .keys_read = fd(14, .{ .scalar = .uint64 }),
        .interval = fd(15, .submessage),
        .cpu_usages = fd(16, .{ .repeated = .submessage }),
        .read_io_rates = fd(17, .{ .repeated = .submessage }),
        .write_io_rates = fd(18, .{ .repeated = .submessage }),
        .op_latencies = fd(19, .{ .repeated = .submessage }),
        .peer_stats = fd(20, .{ .repeated = .submessage }),
        .query_stats = fd(21, .submessage),
        .slow_score = fd(22, .{ .scalar = .uint64 }),
        .damaged_regions_id = fd(23, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .is_apply_busy = fd(24, .{ .scalar = .bool }),
        .snapshot_stats = fd(25, .{ .repeated = .submessage }),
        .slow_trend = fd(26, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SlowTrend = struct {
    cause_value: f64 = 0,
    cause_rate: f64 = 0,
    result_value: f64 = 0,
    result_rate: f64 = 0,

    pub const _desc_table = .{
        .cause_value = fd(1, .{ .scalar = .double }),
        .cause_rate = fd(2, .{ .scalar = .double }),
        .result_value = fd(3, .{ .scalar = .double }),
        .result_rate = fd(4, .{ .scalar = .double }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SnapshotStat = struct {
    region_id: u64 = 0,
    generate_duration_sec: u64 = 0,
    send_duration_sec: u64 = 0,
    total_duration_sec: u64 = 0,
    transport_size: u64 = 0,

    pub const _desc_table = .{
        .region_id = fd(1, .{ .scalar = .uint64 }),
        .generate_duration_sec = fd(2, .{ .scalar = .uint64 }),
        .send_duration_sec = fd(3, .{ .scalar = .uint64 }),
        .total_duration_sec = fd(4, .{ .scalar = .uint64 }),
        .transport_size = fd(5, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PeerReport = struct {
    raft_state: ?raft_serverpb.RaftLocalState = null,
    region_state: ?raft_serverpb.RegionLocalState = null,
    is_force_leader: bool = false,
    has_commit_merge: bool = false,

    pub const _desc_table = .{
        .raft_state = fd(1, .submessage),
        .region_state = fd(2, .submessage),
        .is_force_leader = fd(3, .{ .scalar = .bool }),
        .has_commit_merge = fd(4, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const StoreReport = struct {
    peer_reports: std.ArrayListUnmanaged(PeerReport) = .empty,
    step: u64 = 0,

    pub const _desc_table = .{
        .peer_reports = fd(1, .{ .repeated = .submessage }),
        .step = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const StoreHeartbeatRequest = struct {
    header: ?RequestHeader = null,
    stats: ?StoreStats = null,
    store_report: ?StoreReport = null,
    dr_autosync_status: ?replication_modepb.StoreDRAutoSyncStatus = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .stats = fd(2, .submessage),
        .store_report = fd(3, .submessage),
        .dr_autosync_status = fd(4, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const DemoteFailedVoters = struct {
    region_id: u64 = 0,
    failed_voters: std.ArrayListUnmanaged(metapb.Peer) = .empty,

    pub const _desc_table = .{
        .region_id = fd(1, .{ .scalar = .uint64 }),
        .failed_voters = fd(2, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ForceLeader = struct {
    failed_stores: std.ArrayListUnmanaged(u64) = .empty,
    enter_force_leaders: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .failed_stores = fd(1, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .enter_force_leaders = fd(2, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const RecoveryPlan = struct {
    creates: std.ArrayListUnmanaged(metapb.Region) = .empty,
    updates: std.ArrayListUnmanaged(metapb.Region) = .empty,
    tombstones: std.ArrayListUnmanaged(u64) = .empty,
    demotes: std.ArrayListUnmanaged(DemoteFailedVoters) = .empty,
    force_leader: ?ForceLeader = null,
    step: u64 = 0,

    pub const _desc_table = .{
        .creates = fd(1, .{ .repeated = .submessage }),
        .updates = fd(2, .{ .repeated = .submessage }),
        .tombstones = fd(3, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .demotes = fd(4, .{ .repeated = .submessage }),
        .force_leader = fd(5, .submessage),
        .step = fd(6, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const AwakenRegions = struct {
    abnormal_stores: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .abnormal_stores = fd(1, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const StoreHeartbeatResponse = struct {
    header: ?ResponseHeader = null,
    replication_status: ?replication_modepb.ReplicationStatus = null,
    cluster_version: []const u8 = &.{},
    require_detailed_report: bool = false,
    recovery_plan: ?RecoveryPlan = null,
    awaken_regions: ?AwakenRegions = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .replication_status = fd(2, .submessage),
        .cluster_version = fd(3, .{ .scalar = .string }),
        .require_detailed_report = fd(4, .{ .scalar = .bool }),
        .recovery_plan = fd(5, .submessage),
        .awaken_regions = fd(6, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ScatterRegionRequest = struct {
    header: ?RequestHeader = null,
    region_id: u64 = 0,
    region: ?metapb.Region = null,
    leader: ?metapb.Peer = null,
    group: []const u8 = &.{},
    regions_id: std.ArrayListUnmanaged(u64) = .empty,
    retry_limit: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_id = fd(2, .{ .scalar = .uint64 }),
        .region = fd(3, .submessage),
        .leader = fd(4, .submessage),
        .group = fd(5, .{ .scalar = .string }),
        .regions_id = fd(6, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .retry_limit = fd(7, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ScatterRegionResponse = struct {
    header: ?ResponseHeader = null,
    finished_percentage: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .finished_percentage = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetGCSafePointRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetGCSafePointResponse = struct {
    header: ?ResponseHeader = null,
    safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .safe_point = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateGCSafePointRequest = struct {
    header: ?RequestHeader = null,
    safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .safe_point = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateGCSafePointResponse = struct {
    header: ?ResponseHeader = null,
    new_safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .new_safe_point = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateServiceGCSafePointRequest = struct {
    header: ?RequestHeader = null,
    service_id: []const u8 = &.{},
    TTL: i64 = 0,
    safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .service_id = fd(2, .{ .scalar = .bytes }),
        .TTL = fd(3, .{ .scalar = .int64 }),
        .safe_point = fd(4, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateServiceGCSafePointResponse = struct {
    header: ?ResponseHeader = null,
    service_id: []const u8 = &.{},
    TTL: i64 = 0,
    min_safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .service_id = fd(2, .{ .scalar = .bytes }),
        .TTL = fd(3, .{ .scalar = .int64 }),
        .min_safe_point = fd(4, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetGCSafePointV2Request = struct {
    header: ?RequestHeader = null,
    keyspace_id: u32 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .keyspace_id = fd(2, .{ .scalar = .uint32 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetGCSafePointV2Response = struct {
    header: ?ResponseHeader = null,
    safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .safe_point = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const WatchGCSafePointV2Request = struct {
    header: ?RequestHeader = null,
    revision: i64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .revision = fd(2, .{ .scalar = .int64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SafePointEvent = struct {
    keyspace_id: u32 = 0,
    safe_point: u64 = 0,
    type: EventType = @enumFromInt(0),

    pub const _desc_table = .{
        .keyspace_id = fd(1, .{ .scalar = .uint32 }),
        .safe_point = fd(2, .{ .scalar = .uint64 }),
        .type = fd(3, .@"enum"),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const WatchGCSafePointV2Response = struct {
    header: ?ResponseHeader = null,
    events: std.ArrayListUnmanaged(SafePointEvent) = .empty,
    revision: i64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .events = fd(2, .{ .repeated = .submessage }),
        .revision = fd(3, .{ .scalar = .int64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateGCSafePointV2Request = struct {
    header: ?RequestHeader = null,
    keyspace_id: u32 = 0,
    safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .keyspace_id = fd(2, .{ .scalar = .uint32 }),
        .safe_point = fd(3, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateGCSafePointV2Response = struct {
    header: ?ResponseHeader = null,
    new_safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .new_safe_point = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateServiceSafePointV2Request = struct {
    header: ?RequestHeader = null,
    keyspace_id: u32 = 0,
    service_id: []const u8 = &.{},
    safe_point: u64 = 0,
    ttl: i64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .keyspace_id = fd(2, .{ .scalar = .uint32 }),
        .service_id = fd(3, .{ .scalar = .bytes }),
        .safe_point = fd(4, .{ .scalar = .uint64 }),
        .ttl = fd(5, .{ .scalar = .int64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const UpdateServiceSafePointV2Response = struct {
    header: ?ResponseHeader = null,
    service_id: []const u8 = &.{},
    ttl: i64 = 0,
    min_safe_point: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .service_id = fd(2, .{ .scalar = .bytes }),
        .ttl = fd(3, .{ .scalar = .int64 }),
        .min_safe_point = fd(4, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const RegionStat = struct {
    bytes_written: u64 = 0,
    bytes_read: u64 = 0,
    keys_written: u64 = 0,
    keys_read: u64 = 0,

    pub const _desc_table = .{
        .bytes_written = fd(1, .{ .scalar = .uint64 }),
        .bytes_read = fd(2, .{ .scalar = .uint64 }),
        .keys_written = fd(3, .{ .scalar = .uint64 }),
        .keys_read = fd(4, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SyncRegionRequest = struct {
    header: ?RequestHeader = null,
    member: ?Member = null,
    start_index: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .member = fd(2, .submessage),
        .start_index = fd(3, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const PeersStats = struct {
    peers: std.ArrayListUnmanaged(PeerStats) = .empty,

    pub const _desc_table = .{
        .peers = fd(1, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const Peers = struct {
    peers: std.ArrayListUnmanaged(metapb.Peer) = .empty,

    pub const _desc_table = .{
        .peers = fd(1, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SyncRegionResponse = struct {
    header: ?ResponseHeader = null,
    regions: std.ArrayListUnmanaged(metapb.Region) = .empty,
    start_index: u64 = 0,
    region_stats: std.ArrayListUnmanaged(RegionStat) = .empty,
    region_leaders: std.ArrayListUnmanaged(metapb.Peer) = .empty,
    buckets: std.ArrayListUnmanaged(metapb.Buckets) = .empty,
    down_peers: std.ArrayListUnmanaged(PeersStats) = .empty,
    pending_peers: std.ArrayListUnmanaged(Peers) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .regions = fd(2, .{ .repeated = .submessage }),
        .start_index = fd(3, .{ .scalar = .uint64 }),
        .region_stats = fd(4, .{ .repeated = .submessage }),
        .region_leaders = fd(5, .{ .repeated = .submessage }),
        .buckets = fd(6, .{ .repeated = .submessage }),
        .down_peers = fd(16, .{ .repeated = .submessage }),
        .pending_peers = fd(17, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetOperatorRequest = struct {
    header: ?RequestHeader = null,
    region_id: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_id = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetOperatorResponse = struct {
    header: ?ResponseHeader = null,
    region_id: u64 = 0,
    desc: []const u8 = &.{},
    status: OperatorStatus = @enumFromInt(0),
    kind: []const u8 = &.{},

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_id = fd(2, .{ .scalar = .uint64 }),
        .desc = fd(3, .{ .scalar = .bytes }),
        .status = fd(4, .@"enum"),
        .kind = fd(5, .{ .scalar = .bytes }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SyncMaxTSRequest = struct {
    header: ?RequestHeader = null,
    max_ts: ?Timestamp = null,
    skip_check: bool = false,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .max_ts = fd(2, .submessage),
        .skip_check = fd(3, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SyncMaxTSResponse = struct {
    header: ?ResponseHeader = null,
    max_local_ts: ?Timestamp = null,
    synced_dcs: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .max_local_ts = fd(2, .submessage),
        .synced_dcs = fd(3, .{ .repeated = .{ .scalar = .string } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SplitRegionsRequest = struct {
    header: ?RequestHeader = null,
    split_keys: std.ArrayListUnmanaged([]const u8) = .empty,
    retry_limit: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .split_keys = fd(2, .{ .repeated = .{ .scalar = .bytes } }),
        .retry_limit = fd(3, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SplitRegionsResponse = struct {
    header: ?ResponseHeader = null,
    finished_percentage: u64 = 0,
    regions_id: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .finished_percentage = fd(2, .{ .scalar = .uint64 }),
        .regions_id = fd(3, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SplitAndScatterRegionsRequest = struct {
    header: ?RequestHeader = null,
    split_keys: std.ArrayListUnmanaged([]const u8) = .empty,
    group: []const u8 = &.{},
    retry_limit: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .split_keys = fd(2, .{ .repeated = .{ .scalar = .bytes } }),
        .group = fd(3, .{ .scalar = .string }),
        .retry_limit = fd(4, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SplitAndScatterRegionsResponse = struct {
    header: ?ResponseHeader = null,
    split_finished_percentage: u64 = 0,
    scatter_finished_percentage: u64 = 0,
    regions_id: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .split_finished_percentage = fd(2, .{ .scalar = .uint64 }),
        .scatter_finished_percentage = fd(3, .{ .scalar = .uint64 }),
        .regions_id = fd(4, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetDCLocationInfoRequest = struct {
    header: ?RequestHeader = null,
    dc_location: []const u8 = &.{},

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .dc_location = fd(2, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetDCLocationInfoResponse = struct {
    header: ?ResponseHeader = null,
    suffix: i32 = 0,
    max_ts: ?Timestamp = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .suffix = fd(2, .{ .scalar = .int32 }),
        .max_ts = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const QueryStats = struct {
    GC: u64 = 0,
    Get: u64 = 0,
    Scan: u64 = 0,
    Coprocessor: u64 = 0,
    Delete: u64 = 0,
    DeleteRange: u64 = 0,
    Put: u64 = 0,
    Prewrite: u64 = 0,
    AcquirePessimisticLock: u64 = 0,
    Commit: u64 = 0,
    Rollback: u64 = 0,

    pub const _desc_table = .{
        .GC = fd(1, .{ .scalar = .uint64 }),
        .Get = fd(2, .{ .scalar = .uint64 }),
        .Scan = fd(3, .{ .scalar = .uint64 }),
        .Coprocessor = fd(4, .{ .scalar = .uint64 }),
        .Delete = fd(5, .{ .scalar = .uint64 }),
        .DeleteRange = fd(6, .{ .scalar = .uint64 }),
        .Put = fd(7, .{ .scalar = .uint64 }),
        .Prewrite = fd(8, .{ .scalar = .uint64 }),
        .AcquirePessimisticLock = fd(9, .{ .scalar = .uint64 }),
        .Commit = fd(10, .{ .scalar = .uint64 }),
        .Rollback = fd(11, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportBucketsRequest = struct {
    header: ?RequestHeader = null,
    region_epoch: ?metapb.RegionEpoch = null,
    buckets: ?metapb.Buckets = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .region_epoch = fd(2, .submessage),
        .buckets = fd(3, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportBucketsResponse = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportMinResolvedTsRequest = struct {
    header: ?RequestHeader = null,
    store_id: u64 = 0,
    min_resolved_ts: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .store_id = fd(2, .{ .scalar = .uint64 }),
        .min_resolved_ts = fd(3, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const ReportMinResolvedTsResponse = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SetExternalTimestampRequest = struct {
    header: ?RequestHeader = null,
    timestamp: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .timestamp = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const SetExternalTimestampResponse = struct {
    header: ?ResponseHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetExternalTimestampRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetExternalTimestampResponse = struct {
    header: ?ResponseHeader = null,
    timestamp: u64 = 0,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .timestamp = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetMinTSRequest = struct {
    header: ?RequestHeader = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};

pub const GetMinTSResponse = struct {
    header: ?ResponseHeader = null,
    timestamp: ?Timestamp = null,

    pub const _desc_table = .{
        .header = fd(1, .submessage),
        .timestamp = fd(2, .submessage),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return pb.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (pb.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return pb.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return pb.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return pb.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return pb.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return pb.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return pb.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return pb.json.stringify(@This(), self, jws);
    }
};
