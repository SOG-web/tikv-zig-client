// Code generated by protoc-gen-zig
///! package metapb
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;
/// import package encryptionpb
const encryptionpb = @import("encryptionpb.pb.zig");
/// import package rustproto
const rustproto = @import("rustproto.pb.zig");
/// import package gogoproto
const gogoproto = @import("gogoproto.pb.zig");

pub const StoreState = enum(i32) {
    Up = 0,
    Offline = 1,
    Tombstone = 2,
    _,
};

pub const NodeState = enum(i32) {
    Preparing = 0,
    Serving = 1,
    Removing = 2,
    Removed = 3,
    _,
};

pub const PeerRole = enum(i32) {
    Voter = 0,
    Learner = 1,
    IncomingVoter = 2,
    DemotingVoter = 3,
    _,
};

pub const Cluster = struct {
    id: u64 = 0,
    max_peer_count: u32 = 0,

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .uint64 }),
        .max_peer_count = fd(2, .{ .scalar = .uint32 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const StoreLabel = struct {
    key: []const u8 = &.{},
    value: []const u8 = &.{},

    pub const _desc_table = .{
        .key = fd(1, .{ .scalar = .string }),
        .value = fd(2, .{ .scalar = .string }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Store = struct {
    id: u64 = 0,
    address: []const u8 = &.{},
    state: StoreState = @enumFromInt(0),
    labels: std.ArrayListUnmanaged(StoreLabel) = .empty,
    version: []const u8 = &.{},
    peer_address: []const u8 = &.{},
    status_address: []const u8 = &.{},
    git_hash: []const u8 = &.{},
    start_timestamp: i64 = 0,
    deploy_path: []const u8 = &.{},
    last_heartbeat: i64 = 0,
    physically_destroyed: bool = false,
    node_state: NodeState = @enumFromInt(0),

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .uint64 }),
        .address = fd(2, .{ .scalar = .string }),
        .state = fd(3, .@"enum"),
        .labels = fd(4, .{ .repeated = .submessage }),
        .version = fd(5, .{ .scalar = .string }),
        .peer_address = fd(6, .{ .scalar = .string }),
        .status_address = fd(7, .{ .scalar = .string }),
        .git_hash = fd(8, .{ .scalar = .string }),
        .start_timestamp = fd(9, .{ .scalar = .int64 }),
        .deploy_path = fd(10, .{ .scalar = .string }),
        .last_heartbeat = fd(11, .{ .scalar = .int64 }),
        .physically_destroyed = fd(12, .{ .scalar = .bool }),
        .node_state = fd(13, .@"enum"),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const RegionEpoch = struct {
    conf_ver: u64 = 0,
    version: u64 = 0,

    pub const _desc_table = .{
        .conf_ver = fd(1, .{ .scalar = .uint64 }),
        .version = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BucketStats = struct {
    read_bytes: std.ArrayListUnmanaged(u64) = .empty,
    write_bytes: std.ArrayListUnmanaged(u64) = .empty,
    read_qps: std.ArrayListUnmanaged(u64) = .empty,
    write_qps: std.ArrayListUnmanaged(u64) = .empty,
    read_keys: std.ArrayListUnmanaged(u64) = .empty,
    write_keys: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .read_bytes = fd(1, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .write_bytes = fd(2, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .read_qps = fd(3, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .write_qps = fd(4, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .read_keys = fd(5, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .write_keys = fd(6, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Buckets = struct {
    region_id: u64 = 0,
    version: u64 = 0,
    keys: std.ArrayListUnmanaged([]const u8) = .empty,
    stats: ?BucketStats = null,
    period_in_ms: u64 = 0,

    pub const _desc_table = .{
        .region_id = fd(1, .{ .scalar = .uint64 }),
        .version = fd(2, .{ .scalar = .uint64 }),
        .keys = fd(3, .{ .repeated = .{ .scalar = .bytes } }),
        .stats = fd(4, .submessage),
        .period_in_ms = fd(5, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Region = struct {
    id: u64 = 0,
    start_key: []const u8 = &.{},
    end_key: []const u8 = &.{},
    region_epoch: ?RegionEpoch = null,
    peers: std.ArrayListUnmanaged(Peer) = .empty,
    encryption_meta: ?encryptionpb.EncryptionMeta = null,
    is_in_flashback: bool = false,
    flashback_start_ts: u64 = 0,

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .uint64 }),
        .start_key = fd(2, .{ .scalar = .bytes }),
        .end_key = fd(3, .{ .scalar = .bytes }),
        .region_epoch = fd(4, .submessage),
        .peers = fd(5, .{ .repeated = .submessage }),
        .encryption_meta = fd(6, .submessage),
        .is_in_flashback = fd(7, .{ .scalar = .bool }),
        .flashback_start_ts = fd(8, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Peer = struct {
    id: u64 = 0,
    store_id: u64 = 0,
    role: PeerRole = @enumFromInt(0),
    is_witness: bool = false,

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .uint64 }),
        .store_id = fd(2, .{ .scalar = .uint64 }),
        .role = fd(3, .@"enum"),
        .is_witness = fd(4, .{ .scalar = .bool }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};
