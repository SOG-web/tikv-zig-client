// Code generated by protoc-gen-zig
///! package tikvpb
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;
/// import package mpp
const mpp = @import("mpp.pb.zig");
/// import package raft_serverpb
const raft_serverpb = @import("raft_serverpb.pb.zig");
/// import package gogoproto
const gogoproto = @import("gogoproto.pb.zig");
/// import package coprocessor
const coprocessor = @import("coprocessor.pb.zig");
/// import package kvrpcpb
const kvrpcpb = @import("kvrpcpb.pb.zig");
/// import package disaggregated
const disaggregated = @import("disaggregated.pb.zig");
/// import package rustproto
const rustproto = @import("rustproto.pb.zig");

pub const BatchCommandsRequest = struct {
    requests: std.ArrayListUnmanaged(BatchCommandsRequest.Request) = .empty,
    request_ids: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .requests = fd(1, .{ .repeated = .submessage }),
        .request_ids = fd(2, .{ .packed_repeated = .{ .scalar = .uint64 } }),
    };

    pub const Request = struct {
        cmd: ?cmd_union = null,

        pub const _cmd_case = enum {
            Get,
            Scan,
            Prewrite,
            Commit,
            Import,
            Cleanup,
            BatchGet,
            BatchRollback,
            ScanLock,
            ResolveLock,
            GC,
            DeleteRange,
            RawGet,
            RawBatchGet,
            RawPut,
            RawBatchPut,
            RawDelete,
            RawBatchDelete,
            RawScan,
            RawDeleteRange,
            RawBatchScan,
            Coprocessor,
            PessimisticLock,
            PessimisticRollback,
            CheckTxnStatus,
            TxnHeartBeat,
            CheckSecondaryLocks,
            RawCoprocessor,
            FlashbackToVersion,
            PrepareFlashbackToVersion,
            Empty,
        };
        pub const cmd_union = union(_cmd_case) {
            Get: kvrpcpb.GetRequest,
            Scan: kvrpcpb.ScanRequest,
            Prewrite: kvrpcpb.PrewriteRequest,
            Commit: kvrpcpb.CommitRequest,
            Import: kvrpcpb.ImportRequest,
            Cleanup: kvrpcpb.CleanupRequest,
            BatchGet: kvrpcpb.BatchGetRequest,
            BatchRollback: kvrpcpb.BatchRollbackRequest,
            ScanLock: kvrpcpb.ScanLockRequest,
            ResolveLock: kvrpcpb.ResolveLockRequest,
            GC: kvrpcpb.GCRequest,
            DeleteRange: kvrpcpb.DeleteRangeRequest,
            RawGet: kvrpcpb.RawGetRequest,
            RawBatchGet: kvrpcpb.RawBatchGetRequest,
            RawPut: kvrpcpb.RawPutRequest,
            RawBatchPut: kvrpcpb.RawBatchPutRequest,
            RawDelete: kvrpcpb.RawDeleteRequest,
            RawBatchDelete: kvrpcpb.RawBatchDeleteRequest,
            RawScan: kvrpcpb.RawScanRequest,
            RawDeleteRange: kvrpcpb.RawDeleteRangeRequest,
            RawBatchScan: kvrpcpb.RawBatchScanRequest,
            Coprocessor: coprocessor.Request,
            PessimisticLock: kvrpcpb.PessimisticLockRequest,
            PessimisticRollback: kvrpcpb.PessimisticRollbackRequest,
            CheckTxnStatus: kvrpcpb.CheckTxnStatusRequest,
            TxnHeartBeat: kvrpcpb.TxnHeartBeatRequest,
            CheckSecondaryLocks: kvrpcpb.CheckSecondaryLocksRequest,
            RawCoprocessor: kvrpcpb.RawCoprocessorRequest,
            FlashbackToVersion: kvrpcpb.FlashbackToVersionRequest,
            PrepareFlashbackToVersion: kvrpcpb.PrepareFlashbackToVersionRequest,
            Empty: BatchCommandsEmptyRequest,
            pub const _desc_table = .{
                .Get = fd(1, .submessage),
                .Scan = fd(2, .submessage),
                .Prewrite = fd(3, .submessage),
                .Commit = fd(4, .submessage),
                .Import = fd(5, .submessage),
                .Cleanup = fd(6, .submessage),
                .BatchGet = fd(7, .submessage),
                .BatchRollback = fd(8, .submessage),
                .ScanLock = fd(9, .submessage),
                .ResolveLock = fd(10, .submessage),
                .GC = fd(11, .submessage),
                .DeleteRange = fd(12, .submessage),
                .RawGet = fd(13, .submessage),
                .RawBatchGet = fd(14, .submessage),
                .RawPut = fd(15, .submessage),
                .RawBatchPut = fd(16, .submessage),
                .RawDelete = fd(17, .submessage),
                .RawBatchDelete = fd(18, .submessage),
                .RawScan = fd(19, .submessage),
                .RawDeleteRange = fd(20, .submessage),
                .RawBatchScan = fd(21, .submessage),
                .Coprocessor = fd(22, .submessage),
                .PessimisticLock = fd(23, .submessage),
                .PessimisticRollback = fd(24, .submessage),
                .CheckTxnStatus = fd(25, .submessage),
                .TxnHeartBeat = fd(26, .submessage),
                .CheckSecondaryLocks = fd(33, .submessage),
                .RawCoprocessor = fd(34, .submessage),
                .FlashbackToVersion = fd(35, .submessage),
                .PrepareFlashbackToVersion = fd(36, .submessage),
                .Empty = fd(255, .submessage),
            };
        };

        pub const _desc_table = .{
            .cmd = fd(null, .{ .oneof = cmd_union }),
        };

        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BatchCommandsResponse = struct {
    responses: std.ArrayListUnmanaged(BatchCommandsResponse.Response) = .empty,
    request_ids: std.ArrayListUnmanaged(u64) = .empty,
    transport_layer_load: u64 = 0,

    pub const _desc_table = .{
        .responses = fd(1, .{ .repeated = .submessage }),
        .request_ids = fd(2, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .transport_layer_load = fd(3, .{ .scalar = .uint64 }),
    };

    pub const Response = struct {
        cmd: ?cmd_union = null,

        pub const _cmd_case = enum {
            Get,
            Scan,
            Prewrite,
            Commit,
            Import,
            Cleanup,
            BatchGet,
            BatchRollback,
            ScanLock,
            ResolveLock,
            GC,
            DeleteRange,
            RawGet,
            RawBatchGet,
            RawPut,
            RawBatchPut,
            RawDelete,
            RawBatchDelete,
            RawScan,
            RawDeleteRange,
            RawBatchScan,
            Coprocessor,
            PessimisticLock,
            PessimisticRollback,
            CheckTxnStatus,
            TxnHeartBeat,
            CheckSecondaryLocks,
            RawCoprocessor,
            FlashbackToVersion,
            PrepareFlashbackToVersion,
            Empty,
        };
        pub const cmd_union = union(_cmd_case) {
            Get: kvrpcpb.GetResponse,
            Scan: kvrpcpb.ScanResponse,
            Prewrite: kvrpcpb.PrewriteResponse,
            Commit: kvrpcpb.CommitResponse,
            Import: kvrpcpb.ImportResponse,
            Cleanup: kvrpcpb.CleanupResponse,
            BatchGet: kvrpcpb.BatchGetResponse,
            BatchRollback: kvrpcpb.BatchRollbackResponse,
            ScanLock: kvrpcpb.ScanLockResponse,
            ResolveLock: kvrpcpb.ResolveLockResponse,
            GC: kvrpcpb.GCResponse,
            DeleteRange: kvrpcpb.DeleteRangeResponse,
            RawGet: kvrpcpb.RawGetResponse,
            RawBatchGet: kvrpcpb.RawBatchGetResponse,
            RawPut: kvrpcpb.RawPutResponse,
            RawBatchPut: kvrpcpb.RawBatchPutResponse,
            RawDelete: kvrpcpb.RawDeleteResponse,
            RawBatchDelete: kvrpcpb.RawBatchDeleteResponse,
            RawScan: kvrpcpb.RawScanResponse,
            RawDeleteRange: kvrpcpb.RawDeleteRangeResponse,
            RawBatchScan: kvrpcpb.RawBatchScanResponse,
            Coprocessor: coprocessor.Response,
            PessimisticLock: kvrpcpb.PessimisticLockResponse,
            PessimisticRollback: kvrpcpb.PessimisticRollbackResponse,
            CheckTxnStatus: kvrpcpb.CheckTxnStatusResponse,
            TxnHeartBeat: kvrpcpb.TxnHeartBeatResponse,
            CheckSecondaryLocks: kvrpcpb.CheckSecondaryLocksResponse,
            RawCoprocessor: kvrpcpb.RawCoprocessorResponse,
            FlashbackToVersion: kvrpcpb.FlashbackToVersionResponse,
            PrepareFlashbackToVersion: kvrpcpb.PrepareFlashbackToVersionResponse,
            Empty: BatchCommandsEmptyResponse,
            pub const _desc_table = .{
                .Get = fd(1, .submessage),
                .Scan = fd(2, .submessage),
                .Prewrite = fd(3, .submessage),
                .Commit = fd(4, .submessage),
                .Import = fd(5, .submessage),
                .Cleanup = fd(6, .submessage),
                .BatchGet = fd(7, .submessage),
                .BatchRollback = fd(8, .submessage),
                .ScanLock = fd(9, .submessage),
                .ResolveLock = fd(10, .submessage),
                .GC = fd(11, .submessage),
                .DeleteRange = fd(12, .submessage),
                .RawGet = fd(13, .submessage),
                .RawBatchGet = fd(14, .submessage),
                .RawPut = fd(15, .submessage),
                .RawBatchPut = fd(16, .submessage),
                .RawDelete = fd(17, .submessage),
                .RawBatchDelete = fd(18, .submessage),
                .RawScan = fd(19, .submessage),
                .RawDeleteRange = fd(20, .submessage),
                .RawBatchScan = fd(21, .submessage),
                .Coprocessor = fd(22, .submessage),
                .PessimisticLock = fd(23, .submessage),
                .PessimisticRollback = fd(24, .submessage),
                .CheckTxnStatus = fd(25, .submessage),
                .TxnHeartBeat = fd(26, .submessage),
                .CheckSecondaryLocks = fd(33, .submessage),
                .RawCoprocessor = fd(34, .submessage),
                .FlashbackToVersion = fd(35, .submessage),
                .PrepareFlashbackToVersion = fd(36, .submessage),
                .Empty = fd(255, .submessage),
            };
        };

        pub const _desc_table = .{
            .cmd = fd(null, .{ .oneof = cmd_union }),
        };

        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BatchRaftMessage = struct {
    msgs: std.ArrayListUnmanaged(raft_serverpb.RaftMessage) = .empty,

    pub const _desc_table = .{
        .msgs = fd(1, .{ .repeated = .submessage }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BatchCommandsEmptyRequest = struct {
    test_id: u64 = 0,
    delay_time: u64 = 0,

    pub const _desc_table = .{
        .test_id = fd(1, .{ .scalar = .uint64 }),
        .delay_time = fd(2, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BatchCommandsEmptyResponse = struct {
    test_id: u64 = 0,

    pub const _desc_table = .{
        .test_id = fd(1, .{ .scalar = .uint64 }),
    };

    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};
